//
// Generator.cs
//
// Authors:
//  Eric Butler <eric@extremeboredom.net>
//  See AUTHORS for a full list of contributors.
//
// (C) 2005, Eric Butler <eric@extremeboredom.net>
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// // without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections;
using System.Xml;
using GladeCodeGenerator;
using System.Text;
using System.IO;
using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;
using System.Reflection;

namespace GladeCodeGenerator
{
	public class Generator
	{
		string fileName = "";
		WidgetCollection widgets = new WidgetCollection();

		public static ArrayList AssembliesToSearch = new ArrayList();

		public Generator(string fileName)
		{
			/* This is used for Util.GetTypeFromString */
			LoadAssembly("gtk-sharp");
			LoadAssembly("gnome-sharp");
			LoadAssembly("glib-sharp");
			LoadAssembly("glade-sharp");

			this.fileName = fileName;
	//		LoadFile();
		}

		private void LoadAssembly(string partialName)
		{
			try {
				AssembliesToSearch.Add(Assembly.LoadWithPartialName(partialName));
			} catch (Exception ex) {
				Console.WriteLine("Error loading " + partialName + ": " + ex.Message);
			}
		}

		public WidgetCollection Widgets {
			get {
				return widgets;
			}
		}

		private delegate void LoadFileDelegate();

		public void BeginLoadFile(AsyncCallback callback)
		{
			LoadFileDelegate loadFileDelegate = new LoadFileDelegate(LoadFile);
			IAsyncResult result = loadFileDelegate.BeginInvoke(callback, null);
		}

		public void EndLoadFile(IAsyncResult result)
		{
			//Console.WriteLine("EndLoadFile");
		}
		
		public void LoadFile()
		{
			XmlDocument document = new XmlDocument();
			document.Load(fileName);
			
			//ParseNode(null, document.SelectSingleNode("/glade-interface"));
			ParseNode(null, document["glade-interface"]);
		}

		Widget lastWidget;

		private void ParseNode(Widget parentWindow, XmlNode node)
		{
			foreach (XmlNode child in node.ChildNodes) {

				if (child.Name == "widget") {
					
					string widgetClass = child.Attributes["class"].Value;
					string widgetName = child.Attributes["id"].Value;

					Widget widget = new Widget(widgetClass, widgetName);
 
	//				if (widgetClass == "GtkWindow" | widgetClass == "GtkMenu" | widgetClass == "GnomeApp" | widgetClass.EndsWith("Dialog") ) {
					if (child.ParentNode.Name == "glade-interface") {
						widgets.Add(widget);
						parentWindow = widget;
					} else {
						parentWindow.Widgets.Add(widget);
					}
					lastWidget = widget;
					
				} else if (child.Name == "signal") {
					
					string signalName = child.Attributes["name"].Value;
					string signalHandler = child.Attributes["handler"].Value;

					lastWidget.Signals.Add(new Signal(lastWidget, signalName, signalHandler));

				}

				ParseNode(parentWindow, child);
			}
		}

		public void GenerateCode (Language language, string outputDirectory)
		{
			foreach (Widget widget in Widgets) {
				if (widget.GenerateCode) {

					CodeNamespace codeNamespace = new CodeNamespace("Generated");
			
					codeNamespace.Comments.Add( new CodeCommentStatement("Auto-generated by Glade# Code Generator"));
					codeNamespace.Comments.Add( new CodeCommentStatement("http://eric.extremeboredom.net/projects/gladesharpcodegenerator/"));
			
					codeNamespace.Imports.Add(new CodeNamespaceImport("Gtk"));

					CodeTypeDeclaration myClass = new CodeTypeDeclaration(widget.Name);
					myClass.IsClass = true;
	
					string type = Util.ConvertType(widget.Type);
						
					string thisWidgetName = "this" + Util.GetTypeFromString(type).Name;
					CodeMemberField thisWidgetMember = new CodeMemberField(type, thisWidgetName);
					myClass.Members.Add(thisWidgetMember);

					
					CodeConstructor ctor = new CodeConstructor();
					ctor.Attributes = MemberAttributes.Public;

					CodeVariableDeclarationStatement xmlStatement = new CodeVariableDeclarationStatement("Glade.XML", "glade");
					xmlStatement.InitExpression = new CodeObjectCreateExpression("Glade.XML", 
							new CodePrimitiveExpression(new FileInfo(this.fileName).Name),
							new CodePrimitiveExpression(widget.Name), 
							new CodePrimitiveExpression(null));

					CodeMethodInvokeExpression autoConnectInvoke = new CodeMethodInvokeExpression(
							new CodeVariableReferenceExpression("glade"),
							"Autoconnect", 
							new CodeExpression[] {new CodeThisReferenceExpression()});
				
					CodeMethodInvokeExpression getThisWindowInvoke = new CodeMethodInvokeExpression(
							new CodeVariableReferenceExpression("glade"),
							"GetWidget", 
							new CodeExpression[] { new CodePrimitiveExpression(widget.Name) });

					
					CodeAssignStatement assignThisWindowStatement = new CodeAssignStatement(
							new CodeVariableReferenceExpression(thisWidgetName),
							//new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), thisWidgetName),
							new CodeCastExpression(type, getThisWindowInvoke));
					
					ctor.Statements.Add(xmlStatement);
					ctor.Statements.Add(autoConnectInvoke);
					ctor.Statements.Add(assignThisWindowStatement);
					
					myClass.Members.Add(ctor);


					/* Always .Show() */
					CodeMemberMethod showMethod = new CodeMemberMethod();
					showMethod.Name = "Show";
					CodeMethodInvokeExpression showInvoke = new CodeMethodInvokeExpression(
							new CodeVariableReferenceExpression(thisWidgetName),
							"Show");
					showMethod.Statements.Add(showInvoke);

					if (widget.Type == "GtkWindow" | widget.Type == "GnomeApp") {

						//TODO: Anything else to add here? Show() above might be enough...

						CodeMemberMethod destroyMethod = new CodeMemberMethod();
						destroyMethod.Name = "Destroy";
						CodeMethodInvokeExpression destroyInvoke = new CodeMethodInvokeExpression(
							new CodeVariableReferenceExpression(thisWidgetName),
							"Destroy");
						destroyMethod.Statements.Add(destroyInvoke);
						destroyMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final;
						myClass.Members.Add(destroyMethod);
						

					} else if (widget.Type.EndsWith("Dialog")) {

						showMethod.Statements.Add(new CodeSnippetStatement());
						
						/* Add .Run() stuff for dialogs */
						showMethod.Name = "Run";
						showMethod.ReturnType = new CodeTypeReference(typeof(int));

						// int result = 0;
						CodeVariableDeclarationStatement resultVariable = new CodeVariableDeclarationStatement(
								typeof(int),
								"result",
								new CodePrimitiveExpression(0));
						showMethod.Statements.Add(resultVariable);

						// while (true) {
						CodeIterationStatement whileLoop = new CodeIterationStatement();
						whileLoop.InitStatement = new CodeSnippetStatement("");
						whileLoop.IncrementStatement = new CodeSnippetStatement("");
						whileLoop.TestExpression = new CodePrimitiveExpression(true);
						
						whileLoop.Statements.Add(
							new CodeAssignStatement(
								new CodeVariableReferenceExpression("result"),
								new CodeMethodInvokeExpression(
									new CodeVariableReferenceExpression(thisWidgetName), 
									"Run"
								)
							)
						);

						CodeConditionStatement ifStatement = new CodeConditionStatement();
						CodeBinaryOperatorExpression ifStatementCondition = new CodeBinaryOperatorExpression();
						ifStatementCondition.Left = new CodeVariableReferenceExpression("result");
						ifStatementCondition.Operator = CodeBinaryOperatorType.IdentityInequality;
						ifStatementCondition.Right = new CodeCastExpression(typeof(int),
							new CodeVariableReferenceExpression("Gtk.ResponseType.None") // TODO: This doesn't seem right
						);
						ifStatement.Condition = ifStatementCondition;
						ifStatement.TrueStatements.Add(new CodeExpressionStatement(new CodeSnippetExpression("break"))); //TODO: This isnt language independent!
								
						whileLoop.Statements.Add(ifStatement);
						showMethod.Statements.Add(whileLoop);


						CodeMethodInvokeExpression destroyInvoke = new CodeMethodInvokeExpression(
							new CodeVariableReferenceExpression(thisWidgetName),
							"Destroy");

						showMethod.Statements.Add(destroyInvoke);
						showMethod.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("result")));
						
	
						
					} else if (widget.Type == "GtkMenu") {
						showMethod.Name = "Popup";	
						CodeMethodInvokeExpression popupInvoke = new CodeMethodInvokeExpression(
							new CodeVariableReferenceExpression(thisWidgetName),
							"Popup" );
						showMethod.Statements.Add(popupInvoke);
						
					} else {
						throw new Exception("Unknown type: " + widget.Type);
					}
					
					
					showMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final;
					myClass.Members.Add(showMethod);
					
					
					foreach (Widget child in widget.Widgets) {
						if (child.GenerateCode) {

							string childType = Util.ConvertType(child.Type);

							CodeMemberField member = new CodeMemberField(childType, child.Name);
							member.CustomAttributes.Add(new CodeAttributeDeclaration("Glade.Widget"));
							myClass.Members.Add(member);

						}

						foreach (Signal signal in child.Signals) {
							myClass.Members.Add(CreateSignalHandler(child, signal));
						}
					}

					foreach (Signal signal in widget.Signals) {
						myClass.Members.Add(CreateSignalHandler(widget, signal));
					}
					
					codeNamespace.Types.Add(myClass);


					CodeDomProvider provider;
					if (language == Language.CSharp) {
						provider = new CSharpCodeProvider();
					} else if (language == Language.VisualBasic) {
					       provider = new Microsoft.VisualBasic.VBCodeProvider();
				       	} else if (language == Language.Boo) {
						Assembly assembly = Assembly.LoadWithPartialName("Boo.Lang.CodeDom");
						if (assembly == null)
							throw new Exception ("Boo was either not found or is not installed.");
						provider = (CodeDomProvider)assembly.CreateInstance("Boo.Lang.CodeDom.BooCodeProvider");
					} else if (language == Language.Nemerle){
						Assembly assembly = Assembly.LoadWithPartialName("Nemerle.Compiler");
						if (assembly == null)
							throw new Exception ("Nemerle was either not found or is not installed.");
						provider = (CodeDomProvider)assembly.CreateInstance("Nemerle.Compiler.NemerleCodeProvider");
					} else {
						throw new Exception ("Unsupported language");
					}	

					using (StreamWriter streamWriter = new StreamWriter(Path.Combine(outputDirectory, widget.Name + "." +provider.FileExtension))) {
						ICodeGenerator codeGen = provider.CreateGenerator();
						CodeGeneratorOptions codeOptions = new CodeGeneratorOptions();
						codeOptions.BracingStyle = "C";
						codeOptions.IndentString = "\t";
						codeGen.GenerateCodeFromNamespace(codeNamespace, streamWriter, codeOptions);
					}
				}
			}
		}

		private CodeMemberMethod CreateSignalHandler(Widget widget, Signal signal)
		{
			CodeMemberMethod handler = new CodeMemberMethod();
			handler.Name = signal.Handler;

			// TODO: Fix Util.ConvertSignal so we can switch this back!!
			//MethodInfo invokeInfo = Type.GetType("System.EventHandler").GetMethod("Invoke");
			MethodInfo invokeInfo = signal.GetEventHandlerType().GetMethod("Invoke");

			foreach (ParameterInfo parm in invokeInfo.GetParameters()) {
				handler.Parameters.Add(new CodeParameterDeclarationExpression(parm.ParameterType.FullName, parm.Name));
			}

			handler.Statements.Add(new CodeCommentStatement("TODO: Write code to handle the " + signal.Name + " event here."));
			return handler;
		}


		public int CountSelectedWidgets()
		{
			return CountSelectedWidgets(widgets);
		}
		
		public int CountSelectedWidgets(WidgetCollection startAt)
		{
			int count = 0;
			
			foreach (Widget toplevel in startAt) {
				if (toplevel.GenerateCode) {
					count++;
					foreach (Widget widget in toplevel.Widgets) {
						if (widget.GenerateCode)
							count ++;
					}	
				}
			}
			return count;
		}
	}
}
